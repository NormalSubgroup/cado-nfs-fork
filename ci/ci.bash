
tweak_tree_before_configure() { : ; }

step_configure() {
    if [ "$using_cmake_directly" ] ; then
        (cd "$build_tree" ; cmake "$source_tree")
    else
        "${MAKE}" cmake
    fi
    eval `${MAKE} show`
}

build_steps="build1 build2"
build_step_name_build1="Building"

step_build1() {
    if [ "$using_cmake_directly" ] ; then
        SOURCEDIR="$PWD"
        (cd "$build_tree" ; "${MAKE}" -j$NCPUS)
    else
        "${MAKE}" -j$NCPUS
    fi
}

build_step_name_build2="Building test dependencies"
step_build2() {
    if [ "$using_cmake_directly" ] ; then
        SOURCEDIR="$PWD"
        (cd "$build_tree" ; "${MAKE}" -j$NCPUS all_test_dependencies)
    else
        "${MAKE}" -j$NCPUS all_test_dependencies
    fi
}

prepare_valgrind_environment() {
    vdir=$PWD/valgrind.$CI_COMMIT_SHORT_SHA-$CI_JOB_ID
    mkdir -p $vdir
    cat > $vdir/v.sh <<EOF
#!/usr/bin/env bash
cado=$PWD
vdir=$vdir
EOF
    cat >> $vdir/v.sh <<'EOF'
if [ -x "./$1" ] ; then
    prg="$1"
    shift
    args=("./$prg" "$@")
    set -- "${args[@]}"
fi

# Don't use --error-exitcode, so that we get a chance to be notified of all potential errors at once.
valgrind --suppressions=$cado/cado-nfs.supp --gen-suppressions=all --trace-children=yes --trace-children-skip=gzip,libtool,gcc,g++ "--log-file=$vdir/pid-%p" --leak-check=full "$@"
EOF

    VALGRIND="$vdir/v.sh"
    chmod 755 $VALGRIND

    export PYTHONDONTWRITEBYTECODE=1
    test_precommand+=(env TEST_PRECOMMAND=$VALGRIND)
    # valgrind tests can take _ages_ if we run them with openmp
    export OMP_NUM_THREADS=1
}


check_environment() {
    export OMP_DYNAMIC=true
    export STATS_PARSING_ERRORS_ARE_FATAL=1

    test_precommand=()
    if [ "$valgrind" ] ; then
        prepare_valgrind_environment
    fi
    
}


step_coverage() {
    # This takes a coverage file prefix as $1, and info for the kind of
    # file (whether it's "base" or "app", for instance) in $2.
   
    # build_tree and source_tree are used

    outfile="$source_tree/$1-$2.json"

    # Rationale for having this "base" coverage step (and I'm not sure it
    # is still relevant):
    # The "base" coverage file has zero coverage for every instrumented
    # line of the project. At a later stage, we will combine this data
    # file with coverage data files captured after the test run. This way
    # the percentage of total lines covered will always be correct, even
    # when not all source code files were loaded during the test(s).

    # might be useful. We don't want to bother with traces of config
    # checks.
    find "$build_tree" -name '*conftest.gcno' -o -name 'CMake*.gcno' -o -name '?-CMake*.gcno' | xargs -r rm -v

    # ci/ci/001-environment.sh sets build_tree to "./generated" for coverage
    # jobs. Therefore, all files, gcno and gcda, are found under
    # $PWD==$src_tree .
    # This is done so because we have to ship the files that are
    # generated by the build process, and expose them to the merged
    # coverage report.
    # If $build_tree is outside $src_tree, we should add "." before
    # --json
    (set -x ; cd "$build_tree" ; time gcovr --merge-mode-functions=separate -r "$source_tree" --json "$outfile")
}

step_coverage_more_artifacts() {
    prefix="$1"
    if [ "$build_tree" != generated ] ; then
        echo "This part of the script assumes that build_tree=generated"
    fi

    # because of /bin/sh, we can't do arrays.
    find "$build_tree" -name '*.[ch]' -o -name '*.[ch]pp' | xargs -x tar czf ${prefix}-generated-sources.tar.gz
}


coverage_expunge_paths="utils/embedded:gf2x:generated:linalg/bwc/flint-fft:linalg/bwc/mpfq"

dispatch_valgrind_files() {
    cd $vdir
    mkdir ok nok system
    find . -type f -a -name 'pid-*' | xargs egrep -l "Command: (/usr/bin|/bin|python|perl|env|[^ ]*\.sh)" | xargs -r mv --target-directory system
    # the rm -rf step could be considered an option
    rm -rf system
    grep -l 'ERROR SUMMARY: [^0]' pid-* | xargs -r mv -t nok
    ls | grep pid | xargs -r grep -l 'ERROR SUMMARY: 0' | xargs -r mv -t ok
}

postprocess_valgrind() {
    (dispatch_valgrind_files)

    set +e
    ls $vdir/nok | grep -q .
    found_nok_files=$?
    set -e

    ls $vdir/nok | while read f ; do
        cmd=$(perl -ne 'm{Command: \S*/([^/\s]+)} && print "$1\n";' $vdir/nok/$f)
        nerr=$(perl -ne 'm{ERROR SUMMARY: (\d+) errors from (\d+) contexts} && print "$1 from $2\n";' $vdir/nok/$f)
        enter_section errors "Errors in $cmd ($nerr)"
        cat $vdir/nok/$f
        leave_section
    done
    tar czf $vdir.tar.gz $vdir/
    rm -rf $vdir
    if [ $rc != 0 ] ; then
     echo "exit code was $rc"
     exit $rc
    fi
    if [ $found_nok_files = 0 ] ; then
      echo "Found valgrind errors"
      echo "See archive of log files in `hostname`:$vdir.tar.gz"
      exit 1
    fi
}

step_check() {
    # --no-compress-output is perhaps better for test uploading, as ctest
    # likes to store as zlib but headerless, which is a bit of a pain

    ctest_args="-T Test --no-compress-output --test-output-size-passed 4096 --test-output-size-failed 262144"

    if [ "$using_cmake_directly" ] ; then
        set -o pipefail
        (cd "$build_tree" ; "${test_precommand[@]}" ctest -j$NCPUS $ctest_args ) | "$source_tree"/scripts/filter-ctest.pl
    else
        "${test_precommand[@]}" "${MAKE}" check ARGS="-j$NCPUS $ctest_args"
    fi


    if [ "$valgrind" ] ; then
        postprocess_valgrind

    fi
}

step_doc() { : ; }
